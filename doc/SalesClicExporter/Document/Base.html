<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Class: SalesClicExporter::Document::Base</title>
<link rel="stylesheet" href="../../css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="../../css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '../..';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="../../_index.html">Index (B)</a> &raquo; 
    <span class='title'><span class='object_link'><a href="../../SalesClicExporter.html" title="SalesClicExporter (module)">SalesClicExporter</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../Document.html" title="SalesClicExporter::Document (module)">Document</a></span></span>
     &raquo; 
    <span class="title">Base</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: SalesClicExporter::Document::Base
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName">Object</span>
      
        <ul class="fullTree">
          <li>Object</li>
          
            <li class="next">SalesClicExporter::Document::Base</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">lib/sales_clic_exporter/base.rb</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>
All formats will inherit from this class
</p>


  </div>
</div>
<div class="tags">
  
</div><div id="subclasses">
  <h2>Direct Known Subclasses</h2>
  <p class="children"><span class='object_link'><a href="Excel.html" title="SalesClicExporter::Document::Excel (class)">Excel</a></span>, <span class='object_link'><a href="GoogleSpreadsheets.html" title="SalesClicExporter::Document::GoogleSpreadsheets (class)">GoogleSpreadsheets</a></span></p>
</div>



  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#h_table-instance_method" title="#h_table (instance method)">- (Object) <strong>h_table</strong>(values, *headers_with_options) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Ecriture d&#8217;un tableau horizontal avec une matrice de valeurs, et les
entetes des colones (horizontalement) Le second argument comprend les
headers, et les options.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#line-instance_method" title="#line (instance method)">- (Object) <strong>line</strong>(*values) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Ecriture d&#8217;une ligne.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#v_table-instance_method" title="#v_table (instance method)">- (Object) <strong>v_table</strong>(array_of_values, *headers) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Ecriture d&#8217;un tableau vertical avec une colone d&#8217;entetes
(verticalement) et une autre colone de valeurs Prend en 2è argument un
tableau, ou une suite d&#8217;arguments.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write-instance_method" title="#write (instance method)">- (Object) <strong>write</strong> {|_self| ... }</a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Méthode de complésance pour écrire dans le document en utilisant un
bloc.
</p>
</div></span>
  
</li>

      
    </ul>
  



  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="h_table-instance_method">
  
    - (<tt>Object</tt>) <strong>h_table</strong>(values, *headers_with_options) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Ecriture d&#8217;un tableau horizontal avec une matrice de valeurs, et les
entetes des colones (horizontalement) Le second argument comprend les
headers, et les options. Cette syntaxe permet une grande liberté
d&#8217;écriture car on peut spécifier une liste d&#8217;headers comme
liste d&#8217;arguments, puis en dernier argument un hash d&#8217;options
</p>


  </div>
</div>
<div class="tags">
  <h3>Raises:</h3>
<ul class="raise">
  
    <li>
      
        <span class='type'>(<tt>ArgumentError</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/sales_clic_exporter/base.rb', line 77</span>

<span class='def def kw'>def</span> <span class='h_table identifier id'>h_table</span><span class='lparen token'>(</span><span class='values identifier id'>values</span><span class='comma token'>,</span> <span class='mult op'>*</span><span class='headers_with_options identifier id'>headers_with_options</span><span class='rparen token'>)</span>
  <span class='raise identifier id'>raise</span> <span class='ArgumentError constant id'>ArgumentError</span><span class='comma token'>,</span> <span class='string val'>&quot;values should be an array&quot;</span> <span class='unless unless_mod kw'>unless</span> <span class='values identifier id'>values</span><span class='dot token'>.</span><span class='kind_of? fid id'>kind_of?</span><span class='lparen token'>(</span><span class='Array constant id'>Array</span><span class='rparen token'>)</span>

  <span class='comment val'># Extraction du dernier argument</span>
  <span class='options identifier id'>options</span> <span class='assign token'>=</span> <span class='lparen token'>(</span><span class='headers_with_options identifier id'>headers_with_options</span><span class='dot token'>.</span><span class='last identifier id'>last</span><span class='dot token'>.</span><span class='kind_of? fid id'>kind_of?</span><span class='lparen token'>(</span><span class='Hash constant id'>Hash</span><span class='rparen token'>)</span> <span class='andop op'>&amp;&amp;</span> <span class='headers_with_options identifier id'>headers_with_options</span><span class='dot token'>.</span><span class='respond_to? fid id'>respond_to?</span><span class='lparen token'>(</span><span class='string val'>'each'</span><span class='rparen token'>)</span><span class='rparen token'>)</span>   <span class='question op'>?</span>   <span class='headers_with_options identifier id'>headers_with_options</span><span class='dot token'>.</span><span class='pop identifier id'>pop</span>   <span class='colon op'>:</span>   <span class='lbrace token'>{</span><span class='rbrace token'>}</span>
  
  <span class='comment val'># Pour plus de lisibilité on renomme la variable à utiliser dans le reste de la méthode</span>
  <span class='comment val'># Le * permet d'appliatir le tableau d'arguments, qui est contenu dans un tableau sinon (en fait, à ce moment là</span>
  <span class='comment val'># headers_with_options (sans le *) vaut [['a', 'b', 'c']] par exemple</span>
  <span class='headers identifier id'>headers</span> <span class='assign token'>=</span> <span class='mult op'>*</span><span class='headers_with_options identifier id'>headers_with_options</span>

  <span class='comment val'># Dans la méthode #line on utilise le même mécanisme pour contenir les options dans la liste d'arguments.</span>
  <span class='comment val'># C'est pour cette raison qu'on réintègre les options dans le header, et qu'on passe le tout en argument</span>
  <span class='line identifier id'>line</span><span class='lparen token'>(</span><span class='headers identifier id'>headers</span> <span class='lshft op'>&lt;&lt;</span> <span class='options identifier id'>options</span><span class='dot token'>.</span><span class='merge identifier id'>merge</span><span class='lparen token'>(</span><span class='lbrace token'>{</span><span class='symbol val'>:bold</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='true true kw'>true</span><span class='comma token'>,</span> <span class='symbol val'>:wrap_text</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='true true kw'>true</span><span class='rbrace token'>}</span><span class='rparen token'>)</span><span class='rparen token'>)</span>

  <span class='comment val'># Ajout d'une bordure sous les headers</span>
  <span class='comment val'># respond_to? ne prend pas en compte les méthodes privée, on utilise à la place</span>
  <span class='comment val'># private_methods qui renvoie la liste des méthodes privées</span>
  <span class='if if kw'>if</span> <span class='options identifier id'>options</span><span class='lbrack token'>[</span><span class='symbol val'>:border_bottom</span><span class='rbrack token'>]</span> <span class='andop op'>&amp;&amp;</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='private_methods identifier id'>private_methods</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='string val'>'add_bottom_border'</span><span class='rparen token'>)</span>
    <span class='add_bottom_border identifier id'>add_bottom_border</span><span class='lparen token'>(</span><span class='headers identifier id'>headers</span><span class='rparen token'>)</span>
  <span class='end end kw'>end</span>

  <span class='comment val'># Ligne de démarquation</span>
  <span class='newline identifier id'>newline</span><span class='lparen token'>(</span><span class='integer val'>6</span><span class='rparen token'>)</span>

  <span class='values identifier id'>values</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='array_of_values identifier id'>array_of_values</span><span class='bitor op'>|</span>
    <span class='line identifier id'>line</span><span class='lparen token'>(</span><span class='mult op'>*</span><span class='array_of_values identifier id'>array_of_values</span> <span class='lshft op'>&lt;&lt;</span> <span class='options identifier id'>options</span><span class='rparen token'>)</span>
  <span class='end end kw'>end</span>

  <span class='self self kw'>self</span> <span class='comment val'># Pour pouvoir chaîner les méthodes</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="line-instance_method">
  
    - (<tt>Object</tt>) <strong>line</strong>(*values) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Ecriture d&#8217;une ligne
</p>


  </div>
</div>
<div class="tags">
  <h3>Raises:</h3>
<ul class="raise">
  
    <li>
      
        <span class='type'>(<tt>ArgumentError</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/sales_clic_exporter/base.rb', line 110</span>

<span class='def def kw'>def</span> <span class='line identifier id'>line</span><span class='lparen token'>(</span><span class='mult op'>*</span><span class='values identifier id'>values</span><span class='rparen token'>)</span>
  <span class='raise identifier id'>raise</span> <span class='ArgumentError constant id'>ArgumentError</span><span class='comma token'>,</span> <span class='string val'>&quot;values ne peut être vide&quot;</span> <span class='if if_mod kw'>if</span> <span class='values identifier id'>values</span><span class='dot token'>.</span><span class='empty? fid id'>empty?</span>

  <span class='comment val'># Gestion du cas où on passe un tableau plutôt que plusieurs arguments</span>
  <span class='comment val'># Dans ce cas values = [['a', 'b', 'c']] par exemple, ie. le tableau</span>
  <span class='comment val'># passé en paramètre se retrouve dans un tableau, dont on ne prend que le</span>
  <span class='comment val'># premier élément</span>
  <span class='if if kw'>if</span> <span class='values identifier id'>values</span><span class='dot token'>.</span><span class='kind_of? fid id'>kind_of?</span><span class='lparen token'>(</span><span class='Array constant id'>Array</span><span class='rparen token'>)</span> <span class='andop op'>&amp;&amp;</span> <span class='values identifier id'>values</span><span class='dot token'>.</span><span class='size identifier id'>size</span> <span class='eq op'>==</span> <span class='integer val'>1</span> <span class='andop op'>&amp;&amp;</span> <span class='values identifier id'>values</span><span class='dot token'>.</span><span class='first identifier id'>first</span><span class='dot token'>.</span><span class='kind_of? fid id'>kind_of?</span><span class='lparen token'>(</span><span class='Array constant id'>Array</span><span class='rparen token'>)</span>
    <span class='values identifier id'>values</span> <span class='assign token'>=</span> <span class='values identifier id'>values</span><span class='dot token'>.</span><span class='first identifier id'>first</span>
  <span class='end end kw'>end</span>

  <span class='comment val'># Options de formattage</span>
  <span class='comment val'># On prend la dernière valeur du paramètre, si c'est bien un hash</span>
  <span class='comment val'># On procède de cette manière pour pouvoir toujours utiliser la liste</span>
  <span class='comment val'># d'arguments, mais sans spécifier d'options vide, qui serait obligatoire à l'appel</span>
  <span class='comment val'># le cas échéant</span>
  <span class='options identifier id'>options</span> <span class='assign token'>=</span> <span class='values identifier id'>values</span><span class='dot token'>.</span><span class='pop identifier id'>pop</span> <span class='if if_mod kw'>if</span> <span class='values identifier id'>values</span><span class='dot token'>.</span><span class='last identifier id'>last</span><span class='dot token'>.</span><span class='kind_of? fid id'>kind_of?</span><span class='lparen token'>(</span><span class='Hash constant id'>Hash</span><span class='rparen token'>)</span> <span class='andop op'>&amp;&amp;</span> <span class='values identifier id'>values</span><span class='dot token'>.</span><span class='respond_to? fid id'>respond_to?</span><span class='lparen token'>(</span><span class='string val'>'each'</span><span class='rparen token'>)</span>

  <span class='comment val'># Formattage</span>
  <span class='style identifier id'>style</span> <span class='assign token'>=</span> <span class='if if kw'>if</span> <span class='options identifier id'>options</span> <span class='andop op'>&amp;&amp;</span> <span class='options identifier id'>options</span><span class='lbrack token'>[</span><span class='symbol val'>:bold</span><span class='rbrack token'>]</span> <span class='andop op'>&amp;&amp;</span> <span class='options identifier id'>options</span><span class='lbrack token'>[</span><span class='symbol val'>:wrap_text</span><span class='rbrack token'>]</span>
              <span class='string val'>'bold_wrap'</span>
          <span class='elsif elsif kw'>elsif</span> <span class='options identifier id'>options</span> <span class='andop op'>&amp;&amp;</span> <span class='options identifier id'>options</span><span class='lbrack token'>[</span><span class='symbol val'>:wrap_text</span><span class='rbrack token'>]</span>
              <span class='string val'>'wrap'</span>
          <span class='elsif elsif kw'>elsif</span> <span class='options identifier id'>options</span> <span class='andop op'>&amp;&amp;</span> <span class='options identifier id'>options</span><span class='lbrack token'>[</span><span class='symbol val'>:bold</span><span class='rbrack token'>]</span>
              <span class='string val'>'bold'</span>
          <span class='else else kw'>else</span>
            <span class='nil nil kw'>nil</span>
          <span class='end end kw'>end</span>                

  <span class='comment val'># Index de cellule spécifié ? (pour démarer la ligne sur la</span>
  <span class='comment val'># celulle d'index 1 au lieu de 0)</span>
  <span class='cell_index identifier id'>cell_index</span> <span class='assign token'>=</span> <span class='options identifier id'>options</span> <span class='andop op'>&amp;&amp;</span> <span class='options identifier id'>options</span><span class='lbrack token'>[</span><span class='symbol val'>:index</span><span class='rbrack token'>]</span>  <span class='question op'>?</span>   <span class='options identifier id'>options</span><span class='lbrack token'>[</span><span class='symbol val'>:index</span><span class='rbrack token'>]</span>   <span class='colon op'>:</span>   <span class='self self kw'>self</span><span class='dot token'>.</span><span class='class identifier id'>class</span><span class='colon2 op'>::</span><span class='Default_cell_index constant id'>Default_cell_index</span>

  <span class='write_line identifier id'>write_line</span><span class='lparen token'>(</span><span class='values identifier id'>values</span><span class='comma token'>,</span> <span class='cell_index identifier id'>cell_index</span><span class='comma token'>,</span> <span class='style identifier id'>style</span><span class='rparen token'>)</span>

  <span class='increment_row_index identifier id'>increment_row_index</span>

  <span class='self self kw'>self</span> <span class='comment val'># Chainage des méthodes d'écriture</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="v_table-instance_method">
  
    - (<tt>Object</tt>) <strong>v_table</strong>(array_of_values, *headers) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Ecriture d&#8217;un tableau vertical avec une colone d&#8217;entetes
(verticalement) et une autre colone de valeurs Prend en 2è argument un
tableau, ou une suite d&#8217;arguments
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/sales_clic_exporter/base.rb', line 23</span>

<span class='def def kw'>def</span> <span class='v_table identifier id'>v_table</span><span class='lparen token'>(</span><span class='array_of_values identifier id'>array_of_values</span><span class='comma token'>,</span> <span class='mult op'>*</span><span class='headers identifier id'>headers</span><span class='rparen token'>)</span>
  <span class='raise identifier id'>raise</span> <span class='string val'>&quot;array_of_values should be an array&quot;</span> <span class='unless unless_mod kw'>unless</span> <span class='array_of_values identifier id'>array_of_values</span><span class='dot token'>.</span><span class='kind_of? fid id'>kind_of?</span><span class='lparen token'>(</span><span class='Array constant id'>Array</span><span class='rparen token'>)</span>

  <span class='comment val'># Si on passe un tableau, headers prend comme valeur [valeurs du tableau], ie. il</span>
  <span class='comment val'># encapsule les valeurs dans un tableau. Dans ce cas, on pend le premier élément</span>
  <span class='headers identifier id'>headers</span>       <span class='assign token'>=</span> <span class='headers identifier id'>headers</span><span class='dot token'>.</span><span class='first identifier id'>first</span> <span class='if if_mod kw'>if</span> <span class='headers identifier id'>headers</span><span class='dot token'>.</span><span class='is_a? fid id'>is_a?</span><span class='lparen token'>(</span><span class='Array constant id'>Array</span><span class='rparen token'>)</span> <span class='andop op'>&amp;&amp;</span> <span class='headers identifier id'>headers</span><span class='dot token'>.</span><span class='size identifier id'>size</span> <span class='eq op'>==</span> <span class='integer val'>1</span> <span class='andop op'>&amp;&amp;</span> <span class='headers identifier id'>headers</span><span class='dot token'>.</span><span class='first identifier id'>first</span><span class='dot token'>.</span><span class='is_a? fid id'>is_a?</span><span class='lparen token'>(</span><span class='Array constant id'>Array</span><span class='rparen token'>)</span>
  
  <span class='comment val'># On forme un zip des deux tableau, cf. la doc de Ruby (Array#zip).</span>
  <span class='comment val'># La méthode agit comme une transposition (les entetes et les valeurs étant deux vecteurs)</span>
  <span class='comment val'># sauf que les valeurs absentes DU SECOND TABLEAU (celui en paramètre de #zip)</span>
  <span class='comment val'># sont remplacées par nil.</span>
  
  <span class='comment val'># C'est pour cela qu'on va d'abord chercher quel est le tableau le plus petit</span>
  <span class='comment val'># afin d'avoir l'ordre permettant que les 'trous' soient comblés (il faut que</span>
  <span class='comment val'># ce tableau plus petit soit en paramètre).</span>
  <span class='comment val'># Sinon le résultat est tronqué à la première valeur nil trouvée dans le premier tableau</span>
  <span class='comment val'># Par la suite, on va dans ce cas (si l'ordre change) inverser les résultats</span>
  <span class='comment val'># afin de ne pas avoir [VALEUR, COLONE] au lieu de [COLONE, VALEUR]</span>
  <span class='ary_a identifier id'>ary_a</span>         <span class='assign token'>=</span> <span class='headers identifier id'>headers</span><span class='dot token'>.</span><span class='size identifier id'>size</span> <span class='lt op'>&lt;</span> <span class='array_of_values identifier id'>array_of_values</span><span class='dot token'>.</span><span class='size identifier id'>size</span>   <span class='integer val'>? </span>  <span class='array_of_values identifier id'>array_of_values</span>   <span class='colon op'>:</span>   <span class='headers identifier id'>headers</span>
  <span class='ary_b identifier id'>ary_b</span>         <span class='assign token'>=</span> <span class='headers identifier id'>headers</span><span class='dot token'>.</span><span class='size identifier id'>size</span> <span class='lt op'>&lt;</span> <span class='array_of_values identifier id'>array_of_values</span><span class='dot token'>.</span><span class='size identifier id'>size</span>   <span class='integer val'>? </span>  <span class='headers identifier id'>headers</span>           <span class='colon op'>:</span>   <span class='array_of_values identifier id'>array_of_values</span>
  <span class='zipped_values identifier id'>zipped_values</span> <span class='assign token'>=</span> <span class='mult op'>*</span><span class='ary_a identifier id'>ary_a</span><span class='dot token'>.</span><span class='zip identifier id'>zip</span><span class='lparen token'>(</span><span class='ary_b identifier id'>ary_b</span><span class='rparen token'>)</span>

  <span class='comment val'>#Handle the case where array_of_values and headers are Arrays of one unique element</span>
  <span class='comment val'>#In this case, zip does not return an array of array like this [[key,value],[key,value]]</span>
  <span class='comment val'>#But just a simple array [key,value]. In this case, we just write a line</span>
  <span class='unless unless kw'>unless</span> <span class='zipped_values identifier id'>zipped_values</span><span class='dot token'>.</span><span class='first identifier id'>first</span><span class='dot token'>.</span><span class='is_a? fid id'>is_a?</span> <span class='Array constant id'>Array</span>
    <span class='line identifier id'>line</span><span class='lparen token'>(</span><span class='zipped_values identifier id'>zipped_values</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='newline identifier id'>newline</span>
    <span class='return return kw'>return</span> <span class='self self kw'>self</span>
  <span class='end end kw'>end</span>

  <span class='zipped_values identifier id'>zipped_values</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='array_of_two_values identifier id'>array_of_two_values</span><span class='bitor op'>|</span>
    <span class='comment val'># C'est ici qu'on regarde si l'ordre a été changé</span>
    <span class='comment val'># auquel cas on inverse les valeurs du tableau</span>
    <span class='if if kw'>if</span> <span class='headers identifier id'>headers</span><span class='dot token'>.</span><span class='size identifier id'>size</span> <span class='lt op'>&lt;</span> <span class='array_of_values identifier id'>array_of_values</span><span class='dot token'>.</span><span class='size identifier id'>size</span>
      <span class='ary identifier id'>ary</span> <span class='assign token'>=</span> <span class='array_of_two_values identifier id'>array_of_two_values</span><span class='dot token'>.</span><span class='reverse identifier id'>reverse</span>
    <span class='else else kw'>else</span>
      <span class='ary identifier id'>ary</span> <span class='assign token'>=</span> <span class='array_of_two_values identifier id'>array_of_two_values</span>
    <span class='end end kw'>end</span>
    <span class='line identifier id'>line</span><span class='lparen token'>(</span><span class='ary identifier id'>ary</span><span class='rparen token'>)</span>
  <span class='end end kw'>end</span>

  <span class='self self kw'>self</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="write-instance_method">
  
    - (<tt>Object</tt>) <strong>write</strong> {|_self| ... }
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Méthode de complésance pour écrire dans le document en utilisant un bloc
</p>


  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>_self</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Yield Parameters:</h3>
<ul class="yieldparam">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="SalesClicExporter::Document::Base (class)">SalesClicExporter::Document::Base</a></span></tt>)</span>
      
      
        <span class='name'>_self</span>
      
      
      
        &mdash;
        <div class='inline'><p>
the object that the method was called on
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


68
69
70
71</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/sales_clic_exporter/base.rb', line 68</span>

<span class='def def kw'>def</span> <span class='write identifier id'>write</span>
  <span class='yield yield kw'>yield</span><span class='lparen token'>(</span><span class='self self kw'>self</span><span class='rparen token'>)</span> <span class='if if_mod kw'>if</span> <span class='block_given? fid id'>block_given?</span>
  <span class='self self kw'>self</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on 05/16/11 10:59:53 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.7 (ruby-1.8.7).
</div>

  </body>
</html>